# Authoring templates

Output of the code generator is driven by a set of templates that are stored in
the `templates` directory and are installed with the tool. 

The template engine is based on Jinja2, with a few extensions specific to this
generator. The basic Jinja2 template syntax is described in the [Jinja2
documentation](https://jinja.palletsprojects.com/en/3.0.x/templates/).

The generator distinguishes between code generators for endpoints and message 
definition groups and generators that generate code for message payload schemas.

Code generators for message payload schemas are generic and handle JSON Schema,
Avro Schema, and Proto files. In the case of JSON Schema, the template generates
classes for the JSON Schema types. For serializer frameworks like Avro and
Proto, the template generates input files for the serializer framework's native
code-generators that align with the code generated by the other templates.

Code generators for endpoints and message definition groups are specific to the
CloudEvents Discovery format.

## Directory structure

The content of the the `templates` directory is dynamic and extensible.
Underneath `templates` reside subdirectories for each of the supported output
languages. Adding support for a new language is as simple as adding a new
directory.

The tool uses the name of the directory as the language identifier for the
`--language` command line argument.

For tools that wrap the code generator, like the VS Code extension, you can
place a `_templateinfo.json` file in the language directory to provide
a description for the language:

```json
{
    "description" : "C# / .NET 6.0"
}
```

Inside of the language directory, there are subdirectories for each template
set (called "style" to avoid conflations with other overloaded terms).

The tool uses the name of the directory as the style identifier for the
`--style` command line argument.

Here again, for tools that wrap the code generator, like the VS Code extension,
you can place a `_templateinfo.json` file in the style directory to provide a
description for the style:

```json
{
    "description" : "Azure Functions HTTP trigger",
    "priority" : 1
}
```

The `priority` property is used to sort the list of styles in the VS Code
extension in ascending order. The default priority is 100, putting your style
at/near the bottom of the list if you don't specify a priority.

All code templates live grouped in style directories, each set typically
reflecting a full code project, including project files and other assets. All
files you want to emit must be suffixed with `.jinja` and are run through the
Jinja template engine. If you don't put any Jinja template syntax in your file,
it will be copied verbatim to the output directory, with the ".jinja" suffix
stripped.

The filenames of the templates are used to determine the output file name.
Unless you use expansion macros, the file name is used as-is. For example, if
you have a template named `README.md.jinja`, the output file will be named
`README.md`.

Expansion macros are used to generate multiple files from a single template or
to rename the file based on a variable. The following macros are supported:

* `{projectname}` - expands into the name of the generated project.
* `{classname}` - expands into the name of the generated class. If this macro is
  used, a new file is generated for each class representing a message
  definition.
* `{classdir}` - expands into the name of the generated class. If this macro is
  used, a new file is generated for each class representing a message
  definition. The file is placed in a subdirectory reflection the package name.
  This is specifically meant to help with the Java conventions.

The `_schemas` directory inside the language directory is special-cased and
contains the templates for the code generators for message payload schemas.

Schema languages are well-known by the code generator and templates must be
named for the schema format they support.

* _json.{language}.jinja - JSON Schema
* _avro.{language}.jinja - Avro Schema
* _proto.proto.jinja - Proto Schema
 
Note that the file extension for Protobuf is .proto because the emitted file is
a .proto file that is used as input to the Protobuf compiler which generates the
actual code during build of emitted projects. The existing templates edit input
schemas to inject the namespace/package name.

## Template variables

The input document, which is either a CloudEvents Discovery document or a schema
document, is passed to the template as a variable named `root`. The `root`
variable's structure reflects the respective input document.

* For code generators for message payload schemas, the `root` variable is the
  root of the CloudEvents Discovery document, corresponding to the CloudEvent
  Discovery schema type `manifest`.
* For JSON schema, the `root` variable is the root of the JSON schema document.
* For Proto schema, the `root` variable is a string (!) containing the contents
  of the input file.
* For Avro schema, the `root` variable is the root of the Avro schema document.

## Jinja filter extensions

The following Jinja filters are available for use in templates:

#### `pascal` 

Converts a string (including those in camelCase and snake_case) to PascalCase

Example:
    
```jinja
{{ "foo_bar" | pascal }} -> FooBar
```

#### `camel` 

Converts a string (including those in snake_case and PascalCase) to camelCase

Example:
    
```jinja
{{ "foo_bar" | camel }} -> fooBar
```

#### `snake`

Converts a string (including those in camelCase and PascalCase) to snake_case

Example:

```jinja
{{ "fooBar" | snake }} -> foo_bar
```

#### `pad(len)`

Left-justifies a string with spaces to the specified length. This is useful for
sorting version strings in a template.

Example:

```jinja
{{ "1.0" | pad(5) }} -> "  1.0"
{{ "1.0" | pad(5) }} -> " 11.0"
```

#### `strip_namespace`

Strips the namespace/package portion off an expression 

Example:
    
```jinja
{{ "com.example.Foo" | strip_namespace }} -> Foo
```

#### `strip_invalid_identifier_characters`

Strips invalid characters from an identifier. This is useful for converting
strings to identifiers in languages that have stricter rules for identifiers. All
unsupported characters are replaced with an underscore.

Example:

```jinja
{{ "foo-bar" | strip_invalid_identifier_characters }} -> foo_bar
{{ "@foobar" | strip_invalid_identifier_characters }} -> _foobar
```

        
#### `namespace`

Gets the namespace/package portion off an expression

Example:
    
```jinja
{{ "com.example.Foo" | namespace }} -> com.example
```
                
#### `concat_namespace`

Concatenates the namespace/package portions of an expression 

Example:

```jinja	
{{ "com.example.Foo" | concat_namespace }} -> comexampleFoo
```

If you want to pascal case the expression, use the pascal filter first, e.g.

```jinja
{{ "com.example.Foo" | pascal | concat_namespace }} -> ComExampleFoo
```

#### `toyaml`

Formats the given object as YAML. This is useful for emitting parts of the input
document, for instance JSON Schema elements, into YAML documents.

Example:

```jinja
{{ root | toyaml }}
```

#### `proto`

Pretty-prints the given string as a .proto file

Example:

```jinja
{{ root | proto }}
```


#### `schema_type`

Determines the type name of an expression given a schema URL. This filter has
the side-effect that all schema URLs and schema types are collected by the
generator and the schema types are emitted in the generated code.

Example:

```jinja
{{ "https://example.com/schema.json#/definitions/MyType" | schema_type }} -> MyType
```

#### `{% exit %}`

Exits the template without producing any output. This is useful for skipping the 
file if the input document doesn't contain the required information.

Example:

```jinja
{% if root.type is not defined %}{% exit %}{% endif %}
```