{%- import "cloudevents.jinja.include" as cloudEvents -%}
{%- import "eventhubs.jinja.include" as amqp -%}
{%- set messagegroups = root.messagegroups %}
{%- set uses_cloudevents_message = (root | exists( "format", "cloudevents" )) %}
{%- set uses_amqp_message = (root | exists( "format", "amqp" )) %}
{%- set uses_amqp_endpoint = (root | exists( "protocol", "amqp" )) %}
{%- set function_name = project_name | pascal -%}
using System;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Messaging.EventHubs;
using Azure.Messaging.EventHubs.Processor;
using Microsoft.Extensions.Logging;
{%- if uses_cloudevents_message %}
using CloudNative.CloudEvents;
using CloudNative.CloudEvents.Core;
using CloudNative.CloudEvents.SystemTextJson;
using CloudNative.CloudEvents.Avro;
using CloudNative.CloudEvents.Protobuf;
{%- endif %}
 
{% for messagegroup_key, messagegroup in messagegroups.items() -%}
 {%- set pascalGroupName = messagegroup.id | default(messagegroup_key) | pascal -%}
namespace {{ project_name | pascal }}
{
     {%- set class_name = ( pascalGroupName | strip_namespace )+"EventConsumer" %}
    public class {{ class_name }} : IDisposable
    {
        private const string amqpCloudEventPrefix1 = "cloudEvents_";
        private const string amqpCloudEventPrefix2 = "cloudEvents:";
        private EventProcessorClient eventHubProcessorClient;
        private readonly ILogger logger;
        private static readonly CloudEventFormatter jsonFormatter = new JsonEventFormatter();
        private static readonly CloudEventFormatter protoFormatter = new ProtobufEventFormatter();
        private static readonly CloudEventFormatter avroFormatter = new global::CloudNative.CloudEvents.Avro.AvroEventFormatter();
        {{ cloudEvents.DeclareDispatchObjectsFields( messagegroups ) | indent(8) }}
        {{ cloudEvents.DeclareDispatchObjectsConstructor( project_name, class_name, messagegroups, 
          "EventProcessorClient eventHubProcessorClient, ILoggerFactory? loggerFactory", 
          "loggerFactory = loggerFactory ?? Microsoft.Extensions.Logging.Abstractions.NullLoggerFactory.Instance;\n" +
          "this.logger = loggerFactory.CreateLogger<"+class_name+">();\n" +
          "this.eventHubProcessorClient = eventHubProcessorClient;") | indent(8) }}
        {{ cloudEvents.DeclareDispatchObjectsConstructor( project_name, class_name, messagegroups, 
          "EventProcessorClient eventHubProcessorClient", 
          "var loggerFactory = Microsoft.Extensions.Logging.Abstractions.NullLoggerFactory.Instance;\n" +
          "this.logger = loggerFactory.CreateLogger<"+class_name+">();\n" +
          "this.eventHubProcessorClient = eventHubProcessorClient;") | indent(8) }}
        private string? GetCloudEventAttribute(EventData eventData, string key)
        {
            if (eventData.Properties.TryGetValue(amqpCloudEventPrefix1+key, out var value) ||
                eventData.Properties.TryGetValue(amqpCloudEventPrefix2+key, out value))
            {
                return value as string;
            }
            return null;
        } 

        private CloudEvent CloudEventFromEventData(EventData eventData) 
        {
            CloudEventFormatter? formatter = null;
            var contentType = eventData.ContentType?.Split(';')[0];
            if ( contentType != null && contentType.StartsWith("application/cloudevents") )
            {
                formatter = contentType.EndsWith("+proto") ? protoFormatter: contentType.EndsWith("+avro") ? avroFormatter : jsonFormatter;
                return formatter.DecodeStructuredModeMessage(eventData.EventBody.ToStream(), new System.Net.Mime.ContentType(contentType), null);
            }
            else
            {
                // binary mode
                var cloudEvent = new CloudEvent()
                {
                    Data = eventData.EventBody,
                    DataContentType = contentType,
                };
                string? specVersion = GetCloudEventAttribute(eventData, "specversion");
                if (specVersion != "1.0") throw new Exception("Unsupported CloudEvent specversion: " + specVersion);
                string? dataSchema = GetCloudEventAttribute(eventData, "dataschema");
                string? time = GetCloudEventAttribute(eventData, "time");
                string? source = GetCloudEventAttribute(eventData, "source");
                string? subject = GetCloudEventAttribute(eventData, "subject");
                string? type = GetCloudEventAttribute(eventData, "type");
                string? id = GetCloudEventAttribute(eventData, "id");
                if (dataSchema != null) cloudEvent.DataSchema = new Uri(dataSchema);
                if (time != null) cloudEvent.Time = DateTime.Parse(time);
                if (source != null) cloudEvent.Source = new Uri(source);
                if (subject != null) cloudEvent.Subject = subject;
                if (type != null) cloudEvent.Type = type;
                if (id != null) cloudEvent.Id = id;
                foreach (var key in eventData.Properties.Keys)
                {
                    if (key.StartsWith(amqpCloudEventPrefix1) || key.StartsWith(amqpCloudEventPrefix2))
                    {
                        var attributeName = key.Substring(amqpCloudEventPrefix1.Length);
                        cloudEvent[attributeName] = eventData.Properties[key] as string;
                    }
                }
                return cloudEvent;
            }
            
        }

        public static bool IsCloudEvent(EventData eventData) =>
            MimeUtilities.IsCloudEventsContentType(eventData.ContentType) ||
            eventData.Properties.ContainsKey(amqpCloudEventPrefix1) ||
            eventData.Properties.ContainsKey(amqpCloudEventPrefix2);

        private async Task ProcessEventAsync(ProcessEventArgs eventArgs)
        {
            try 
            {
                {%- if uses_cloudevents_message %}
                if ( IsCloudEvent(eventArgs.Data) )
                {
                    var cloudEvent = CloudEventFromEventData(eventArgs.Data);
                    await DispatchCloudEventAsync(cloudEvent);
                }
                {%- endif %}
                {%- if uses_amqp_message %}
                var amqpMessage = eventArgs.Data;
                if (amqpMessage != null)
                {
                    await DispatchMessageAsync(amqpMessage);
                }
                {%- endif %}
            }
            catch (Exception ex)
            {
                this.logger.LogError(ex, "Error processing event");
            }
        }

        private Task ProcessErrorAsync(ProcessErrorEventArgs eventArgs)
        {
            this.logger.LogError(eventArgs.Exception, "Error processing event");
            return Task.CompletedTask;
        }
        
        {%- if uses_cloudevents_message %}        
        public async Task DispatchCloudEventAsync(CloudEvent cloudEvent)
        {
            try 
            {
                {{ cloudEvents.DispatchToDispatchObjects( "cloudEvent", messagegroups, "this.logger" ) | indent(16) }}
            }
            catch (Exception ex)
            {
                this.logger.LogError(ex, "Error dispatching message");
            }
        }
        {%- endif %}

        {%- if uses_amqp_message %}
        public async Task DispatchMessageAsync(EventData eventData)
        {
            try 
            {
                {{ eventhubs.DispatchToDispatchObjects( "eventData", messagegroups, "this.logger" ) | indent(16) }}
            }
            catch (Exception ex)
            {
                this.logger.LogError(ex, "Error dispatching message");
            }
        }
        {%- endif %}

        public async Task StartProcessingAsync(CancellationToken cancellationToken = default)
        {
            eventHubProcessorClient.ProcessEventAsync += ProcessEventAsync;
            eventHubProcessorClient.ProcessErrorAsync += ProcessErrorAsync;
            await eventHubProcessorClient.StartProcessingAsync(cancellationToken);
        }

        public async Task StopProcessingAsync(CancellationToken cancellationToken = default)
        {
            try
            {
                await eventHubProcessorClient.StopProcessingAsync(cancellationToken);
            }
            finally
            {
                // To prevent leaks, the handlers should be removed when processing is complete.

                eventHubProcessorClient.ProcessEventAsync -= ProcessEventAsync;
                eventHubProcessorClient.ProcessErrorAsync -= ProcessErrorAsync;
            }
        }

        public void Dispose()
        {
            this.StopProcessingAsync().GetAwaiter().GetResult();
        }

        {%- if root.endpoints -%} 
        {%- for endpoint_key in root.endpoints.keys() -%}
        {%- set endpoint = root.endpoints[endpoint_key] -%}
        {%- if endpoint.usage == "producer" -%}
        {%- set protocol = endpoint.config.protocol | lower -%}
        {%- if protocol == "amqp" -%}
        {%- set options = endpoint.config.options -%}
        {%- set endpoints = endpoint.config.endpoints %}
        {%- macro createforbody(class_name, endpoints, options) -%}
            if ( fullyQualifiedNamespace == null )
            {
                {%- if endpoints %}
                fullyQualifiedNamespace = "{{ endpoints[0] }}";
                {%- else %}
                throw new ArgumentNullException(nameof(fullyQualifiedNamespace));
                {%- endif %}
            }
            if ( eventHubName == null )
            {
                {%- if options and 'node' in options %}
                eventHubName = "{{ options['node'] }}";
                {%- else %}
                throw new ArgumentNullException(nameof(eventHubName));
                {%- endif %}
            }
            if ( consumerGroupName == null )
            {
                {%- if options and 'consumer_group' in options %}
                consumerGroupName = "{{ options['consumer_group'] }}";
                {%- else %}
                consumerGroupName = "$Default";
                {%- endif %}
            }
            var eventHubProcessorClient = new EventProcessorClient(checkpointBlobClient, consumerGroupName, fullyQualifiedNamespace, eventHubName, credential);
            return new {{ class_name }}(eventHubProcessorClient);
        {%- endmacro %}
        
        public static {{ class_name }} CreateFor{{ endpoint_key | pascal | strip_namespace }}(BlobContainer checkpointBlobClient, Client TokenCredential credential, string? fullyQualifiedNamespace = null, string? eventHubName = null, string? consumerGroupName = null) 
        {   
            {{ createforbody(class_name, endpoints, options) }}
        }

        public static {{ class_name }} CreateFor{{ endpoint_key | pascal | strip_namespace }}(BlobContainer checkpointBlobClient, AzureNamedKeyCredential credential, string? fullyQualifiedNamespace = null, string? eventHubName = null, string? consumerGroupName = null) 
        {       
            {{ createforbody(class_name, endpoints, options) }}
        }

        public static {{ class_name }} CreateFor{{ endpoint_key | pascal | strip_namespace }}(BlobContainer checkpointBlobClient, AzureSasCredential credential, string? fullyQualifiedNamespace = null, string? eventHubName = null, string? consumerGroupName = null) 
        {       
            {{ createforbody(class_name, endpoints, options) }}
        }
        {%- endif -%}
        {%- endif -%}
        {%- endfor -%}
        {% endif %}
    }

}
{% endfor %}