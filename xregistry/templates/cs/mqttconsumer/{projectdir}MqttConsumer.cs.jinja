{%- import "util.jinja.include" as util -%}

using MQTTnet;
using MQTTnet.Client;
using MQTTnet.Client.Options;
using Microsoft.Extensions.Logging;
using CloudNative.CloudEvents;
using CloudNative.CloudEvents.SystemTextJson;
using CloudNative.CloudEvents.Protobuf;
using CloudNative.CloudEvents.Mqtt;
using MQTTnet.Protocol;

namespace {{ project_name | pascal }}
{
    {{ util.EndpointCredentialClasses() | indent(4) }}

    public class MqttConsumer : IDisposable
    {
        public event Func<MqttApplicationMessage, ILogger, Task>? DispatchApplicationMessageAsync;        
        public event Func<CloudEvent, ILogger, Task>? DispatchCloudEventAsync;
        
        private const string ERROR_LOG_TEMPLATE = "Error in MqttConsumer: {0}";
        private const string VERBOSE_LOG_TEMPLATE = "MqttConsumer: {0}";

        private IMqttClient? _client;
        private CloudEventFormatter _jsonFormatter = new JsonEventFormatter();
        private CloudEventFormatter _protoFormatter = new ProtobufEventFormatter();
        private CloudEventFormatter _avroFormatter = new global::CloudNative.CloudEvents.Avro.AvroEventFormatter();
        private EndpointCredential _credential;
        private IMqttClientOptions? _options;
        private string _topic;
        private byte _qos;
        private List<Uri> _endpoints;
        private ILogger Logger { get; }

        internal MqttConsumer(ILogger logger, EndpointCredential credential, Dictionary<string, string> options, List<Uri> endpoints)
        {
            Logger = logger;
            _credential = credential;
            _endpoints = endpoints;
            _client = new MqttFactory().CreateMqttClient();
            if ( options.TryGetValue("topic", out var topic))
            {
                _topic = topic;
            }
            if (options.TryGetValue("qos", out var qos))
            {
                _qos = 1;
                byte.TryParse(qos, out _qos);
            }
            if (_topic == null) throw new ArgumentException("topic is required");
        }
        
        public async Task StartAsync()
        {
            Uri endpoint = _endpoints.First();
            
            var optionsBuilder = new MqttClientOptionsBuilder();
            if (endpoint.Scheme == "mqtts")
            {
                optionsBuilder = optionsBuilder.WithTls();
            }
            optionsBuilder = optionsBuilder.WithTcpServer(endpoint.Host);
            if (_credential is PlainEndpointCredential plainCredential)
            {
                optionsBuilder = optionsBuilder.WithCredentials(plainCredential.ClientId, plainCredential.ClientSecret);
            }
            else if (_credential is TokenEndpointCredential tokenCredential)
            {
                var token = tokenCredential.GetTokenAsync().Result;
                optionsBuilder = optionsBuilder.WithCredentials("Bearer", System.Text.Encoding.ASCII.GetBytes(token));
            }
            _options = optionsBuilder.Build();
            await _client.ConnectAsync(_options);
            _client.UseApplicationMessageReceivedHandler(OnMessageReceived);
            await _client.SubscribeAsync(_topic, (MqttQualityOfServiceLevel)_qos);
            Logger.LogInformation(VERBOSE_LOG_TEMPLATE, "Started MQTT consumer endpoint");
        }

        public async Task StopAsync()
        {
            await _client.DisconnectAsync();
            Logger.LogInformation(VERBOSE_LOG_TEMPLATE, "Stopped MQTT consumer endpoint");
        }
        
        private void OnMessageReceived(MqttApplicationMessageReceivedEventArgs args)
        {
            try
            {
                string contentType = args.ApplicationMessage.ContentType;
                
                if (( contentType?.StartsWith("application/cloudevents") ?? true) ||
                    ( args.ApplicationMessage.UserProperties.Any(p => p.Name == "specversion") &&
                      args.ApplicationMessage.UserProperties.Any(p => p.Name == "type")))
                {
                    CloudEventFormatter formatter = _jsonFormatter;
                    if (contentType != null)
                    {
                        contentType = contentType.ToString().Split(';')[0];
                        if (contentType != null && contentType.EndsWith("+proto"))
                        {
                            formatter = _protoFormatter;
                        }
                        else if (contentType != null && contentType.EndsWith("+avro"))
                        {
                            formatter = _avroFormatter;
                        }
                        else
                        {
                            formatter = _jsonFormatter;
                        }
                    }
                    var cloudEvent = args.ApplicationMessage.ToCloudEvent(formatter);
                    Deliver(cloudEvent);
                }
                else
                {
                    Deliver(args.ApplicationMessage);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ERROR_LOG_TEMPLATE, ex.Message);
            }
        }

        protected void Deliver<T>(T message)
        {
            if ( message is MqttApplicationMessage)
            {
                DispatchApplicationMessageAsync?.Invoke((MqttApplicationMessage)(object)message, Logger);
            }            
            else if (message is CloudEvent && DispatchCloudEventAsync != null)
            {
                DispatchCloudEventAsync.Invoke((CloudEvent)(object)message, Logger);
            }            
        }

        protected void Dispose(bool disposing)
        {
            if (_client != null)
            {
                _client.Dispose();
                _client = null;
            }
        }

        private static MqttConsumer? CreateMqtt(ILogger logger, EndpointCredential credential, string protocol, Dictionary<string, string> options, List<Uri> endpoints)
        {
            switch (protocol)
            {
                case "mqtt":
                    return new MqttConsumer(logger, credential, options, endpoints);
            }
            return null;
        }

        ~MqttConsumer()
        {
            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
            Dispose(disposing: false);
        }

        public void Dispose()
        {
            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}